<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Battle Royale Seguidores com Ranking</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
@import url('https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@400;700&display=swap');

body {
    font-family: 'Chakra Petch', sans-serif;
    background-color: #1a1a2e;
    color: #fff;
    margin: 0;
    display: flex;
    justify-content: center;
    align-items: flex-start;
    padding: 20px;
    position: relative;
    min-height: 100vh;
}

#app-container {
    display: flex;
    flex-direction: column;
    align-items: center;
}

canvas {
    background-color:#0d0d1b;
    border-radius:10px;
    box-shadow:inset 0 0 10px rgba(0,0,0,0.7);
    display:block;
    margin-bottom:10px;
}

.status-box {
    background-color: #2c2c54;
    border-radius: 8px;
    padding: 10px;
    box-shadow:0 2px 10px rgba(0,0,0,0.5);
    width: 750px;
    display:flex;
    flex-direction: column;
    align-items:center;
}

.upload-label {
    transition:all 0.2s ease-in-out;
    padding:8px 16px;
    border-radius:8px;
    font-weight:bold;
    cursor:pointer;
    text-align:center;
    width:90%;
    margin:5px 0;
    background-color:#22c55e;
    color:white;
    display:block;
}
.upload-label:hover {
    opacity:0.9;
}

/* NOVO ESTILO: Cor para o bot√£o de exportar ranking */
.export-button {
    background-color: #3b82f6; /* Azul */
    color: white;
    width: 90%;
    padding: 8px 16px;
    border-radius: 8px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.2s ease;
    margin: 5px 0;
}
.export-button:hover {
    background-color: #2563eb;
}


#side-panel {
    position: absolute;
    right: 20px;
    top: 50%;
    transform: translateY(-50%);
    width: 220px;
    background-color: #2c2c54;
    border-radius: 8px;
    padding: 15px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.5);
    display: flex;
    flex-direction: column;
    gap: 15px;
}

#side-panel button {
    background-color:#3b82f6;
    color:white;
    width: 100%;
    padding: 10px;
    border-radius: 6px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.2s ease;
}
#side-panel button:hover {
    opacity: 0.9;
}

#searchInput {
    width: 100%;
    padding: 8px;
    border-radius: 6px;
    border: 2px solid #4a4e69;
    background-color: #1a1a2e;
    color: #fff;
    font-family: 'Chakra Petch', sans-serif;
}
#searchInput::placeholder {
    color: #aaa;
}

#searchResults {
    margin-top: 5px;
    max-height: 300px;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.result-item {
    display: flex;
    align-items: center;
    background-color: #1a1a2e;
    padding: 8px;
    border-radius: 6px;
    border-left: 4px solid #a7ff83;
}
.result-item img {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    margin-right: 10px;
}
.result-info {
    font-size: 14px;
}
.result-info .username {
    font-weight: bold;
    color: #fff;
    display: block;
    word-break: break-all;
}
.result-info .rank {
    color: #ffc107;
    font-weight: bold;
}

/* ===== NOVO ESTILO ADICIONADO AQUI ===== */
#side-panel a {
    display: block; /* Faz o link ocupar a linha inteira */
    background-color:#0284c7; /* Uma cor um pouco diferente para destacar */
    color: white;
    width: 100%;
    padding: 10px;
    border-radius: 6px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.2s ease;
    text-align: center;
    text-decoration: none; /* Remove o sublinhado do link */
}
#side-panel a:hover {
    opacity: 0.9;
}
/* ===== FIM DO NOVO ESTILO ===== */

</style>
</head>
<body>
<div id="app-container">
    <h1 class="text-2xl font-bold text-center text-[#a7ff83] mb-2">üí• Battle Royale de Seguidores</h1>
    <p id="subTitle" class="text-center text-gray-300 mb-4">Carregue as fotos dos seus seguidores para come√ßar!</p>
    <canvas id="collisionCanvas" width="750" height="600"></canvas>
    
    <div class="status-box">
        <div id="statusMessage" class="text-base font-semibold text-yellow-300 text-center mb-2">Aguardando imagens...</div>
        <input type="file" id="imageUpload" multiple accept="image/*" style="display:none;">
        <label for="imageUpload" class="upload-label">üñºÔ∏è Carregar Fotos</label>
        
        <button id="exportRankingButton" class="export-button" style="display:none;">
            üèÜ Salvar e Exportar Ranking Final
        </button>
        </div>
</div>

<div id="side-panel">
    <button id="resetButton">üîÑ Reiniciar Simula√ß√£o</button>

    <a href="ranking.html" target="_blank">üìä Ver Ranking Final</a>
    <div>
        <h3 class="font-bold text-lg mb-2 text-center text-[#a7ff83]">Ranking</h3>
        <input type="text" id="searchInput" placeholder="Pesquisar seguidor...">
        <div id="searchResults"></div>
    </div>
</div>

<script>
const INITIAL_RADIUS = 2;  
const MAX_RADIUS = 60;
const MAX_SPEED = 1.5;   
const MIN_SPEED = 0.5;   
const ELIMINATION_THRESHOLD = 15;
const NORMAL_GROWTH_RATE = 0.05;
const SLOW_GROWTH_RATE = 0.01;

let canvas, ctx, profiles=[], animationFrameId, isGameOver=false, lastTime=0, followerImageUrls=[];
let eliminationCounter = 1;  
const imageCache = new Map();
let grid; // Otimiza√ß√£o de Colis√£o

// --- Classe para Otimiza√ß√£o de Colis√£o ---
class SpatialGrid {
    constructor(width, height, cellSize) { this.cellSize = cellSize; this.cols = Math.ceil(width / cellSize); this.rows = Math.ceil(height / cellSize); this.grid = new Map(); }
    clear() { this.grid.clear(); }
    insert(profile) { const col = Math.floor(profile.x / this.cellSize); const row = Math.floor(profile.y / this.cellSize); const key = `${col},${row}`; if (!this.grid.has(key)) { this.grid.set(key, []); } this.grid.get(key).push(profile); }
    getNearby(profile) { const nearby = []; const col = Math.floor(profile.x / this.cellSize); const row = Math.floor(profile.y / this.cellSize); for (let r = -1; r <= 1; r++) { for (let c = -1; c <= 1; c++) { const key = `${col + c},${row + r}`; if (this.grid.has(key)) { nearby.push(...this.grid.get(key)); } } } return nearby; }
}

// --- Classe Profile ---
class Profile {
    constructor(id, username, x, y, vx, vy, imageUrl){
        this.id=id; this.username=username; this.x=x; this.y=y; this.vx=vx; this.vy=vy;
        this.radius=INITIAL_RADIUS; this.collisionCount=0; this.alive=true;
        this.eliminationOrder = null;
        this.image=imageCache.get(imageUrl);
        if(!this.image){ this.image=new Image(); this.image.src=imageUrl; imageCache.set(imageUrl,this.image); }
    }
    update(dt,totalAlive){
        if(!this.alive) return;
        let speedFactor = Math.max(MIN_SPEED, Math.min(MAX_SPEED, Math.pow(followerImageUrls.length / totalAlive, 0.4)));
        if(totalAlive <= 10) speedFactor *= 1.8;
        if(totalAlive <= 5) speedFactor *= 2.0;
        if(Math.abs(this.vx)<0.2) this.vx += this.vx>0?0.2:-0.2;
        if(Math.abs(this.vy)<0.2) this.vy += this.vy>0?0.2:-0.2;
        this.x += this.vx * dt * 60 * speedFactor; 
        this.y += this.vy * dt * 60 * speedFactor;
        let currentGrowthRate = NORMAL_GROWTH_RATE;
        if (totalAlive <= 50) { currentGrowthRate = SLOW_GROWTH_RATE; }
        const dynamicFinalRadius = INITIAL_RADIUS + (MAX_RADIUS - INITIAL_RADIUS) * (1 - totalAlive / followerImageUrls.length);
        if(this.radius < dynamicFinalRadius){ this.radius += currentGrowthRate * dt * 60; if(this.radius > dynamicFinalRadius) this.radius = dynamicFinalRadius; }
        if(this.x-this.radius<0){ this.x=this.radius; this.vx*=-1;}
        else if(this.x+this.radius>canvas.width){ this.x=canvas.width-this.radius; this.vx*=-1;}
        if(this.y-this.radius<0){ this.y=this.radius; this.vy*=-1;}
        else if(this.y+this.radius>canvas.height){ this.y=canvas.height-this.radius; this.vy*=-1;}
    }
    draw(ctx, aliveCount){
        if(!this.alive) return;
        if(aliveCount <= 200){
            const barW = this.radius*2; const barH = 3; const barX = this.x - barW/2; const barY = this.y - this.radius - 5; 
            const healthRatio = (ELIMINATION_THRESHOLD - this.collisionCount)/ELIMINATION_THRESHOLD;
            ctx.fillStyle = "rgba(51,51,51,0.6)"; ctx.fillRect(barX, barY, barW, barH);
            let barColor;
            if(healthRatio > 0.6) barColor = "limegreen"; else if(healthRatio > 0.3) barColor = "gold"; else barColor = "red";
            ctx.fillStyle = barColor; ctx.fillRect(barX, barY, barW * healthRatio, barH);
            ctx.strokeStyle = "rgba(255,255,255,0.3)"; ctx.strokeRect(barX, barY, barW, barH);
        }
        ctx.save(); ctx.beginPath(); ctx.arc(this.x,this.y,this.radius,0,Math.PI*2); ctx.clip();
        ctx.drawImage(this.image,this.x-this.radius,this.y-this.radius,this.radius*2,this.radius*2);
        ctx.restore();
    }
}

// --- Fun√ß√µes Principais ---
function initProfiles(){
    canvas=document.getElementById('collisionCanvas'); ctx=canvas.getContext('2d');
    grid = new SpatialGrid(canvas.width, canvas.height, MAX_RADIUS * 2);
    profiles=[]; isGameOver=false; lastTime=performance.now();
    eliminationCounter = 1;
    document.getElementById('subTitle').textContent=`${followerImageUrls.length} perfis em batalha!`;
    document.getElementById('exportRankingButton').style.display = 'none'; // Esconde ao iniciar
    for(let i=0;i<followerImageUrls.length;i++){
        const imageObj=followerImageUrls[i];
        let x=Math.random()*(canvas.width-INITIAL_RADIUS*2)+INITIAL_RADIUS;
        let y=Math.random()*(canvas.height-INITIAL_RADIUS*2)+INITIAL_RADIUS;
        profiles.push(new Profile(i, imageObj.name, x, y, (Math.random()-0.5)*MAX_SPEED, (Math.random()-0.5)*MAX_SPEED, imageObj.url));
    }
    document.getElementById('searchInput').value = '';
    searchRanking();
}

function detectCollisions(alive) {
    if(alive.length < 2) return;
    if(alive.length === 2){
        const [p1, p2] = alive;
        const dist = Math.hypot(p2.x - p1.x, p2.y - p1.y);
        if(dist < p1.radius + p2.radius){ 
            let winner = p1.collisionCount < p2.collisionCount ? p1 : p2;
            let loser = winner === p1 ? p2 : p1;
            if(p1.collisionCount === p2.collisionCount){ loser = Math.random() < 0.5 ? p1 : p2; }
            loser.alive = false; loser.eliminationOrder = eliminationCounter++;
        }
        return;
    }

    grid.clear();
    for (const p of alive) { grid.insert(p); }

    for (const p1 of alive) {
        const nearby = grid.getNearby(p1);
        for (const p2 of nearby) {
            if (p1.id >= p2.id) continue;
            const dist = Math.hypot(p2.x - p1.x, p2.y - p1.y);
            if (dist < p1.radius + p2.radius) {
                const overlap = (p1.radius + p2.radius - dist)/2;
                const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
                const sx=Math.cos(angle)*overlap, sy=Math.sin(angle)*overlap;
                p1.x-=sx; p1.y-=sy; p2.x+=sx; p2.y+=sy;
                p1.vx*=-1; p1.vy*=-1; p2.vx*=-1; p2.vy*=-1;
                p1.collisionCount++; p2.collisionCount++;
                if(p1.collisionCount>=ELIMINATION_THRESHOLD && p1.alive){ p1.alive=false; p1.eliminationOrder = eliminationCounter++; }
                if(p2.collisionCount>=ELIMINATION_THRESHOLD && p2.alive){ p2.alive=false; p2.eliminationOrder = eliminationCounter++; }
            }
        }
    }
}

function drawPodium() {
    const alive = profiles.filter(p=>p.alive);
    if(alive.length === 0) return;
    const champion = alive[0];
    const dead = profiles.filter(p=>!p.alive).sort((a,b)=>b.eliminationOrder - a.eliminationOrder);
    const second = dead[0] || null; 
    const third = dead[1] || null;  

    const podiumData = [
        {profile: champion, y: canvas.height*0.20, label:"CAMPE√ÉO", radius: canvas.width*0.45, fontSize:36, nameSize:26},
        second ? {profile: second, y: canvas.height*0.55, label:"2¬∫ LUGAR", radius: canvas.width*0.28, fontSize:24, nameSize:16} : null,
        third ? {profile: third, y: canvas.height*0.82, label:"3¬∫ LUGAR", radius: canvas.width*0.18, fontSize:24, nameSize:16} : null
    ].filter(Boolean);
    
    podiumData.forEach(pos=>{
        const p = pos.profile;
        p.radius += (pos.radius - p.radius) * 0.05;
        ctx.save(); ctx.beginPath(); ctx.arc(canvas.width/2, pos.y, p.radius, 0, Math.PI*2); ctx.clip();
        ctx.drawImage(p.image, canvas.width/2 - p.radius, pos.y - p.radius, p.radius*2, p.radius*2); ctx.restore();
        ctx.fillStyle="gold"; ctx.textAlign="center"; ctx.font = `bold ${pos.fontSize}px Chakra Petch`;
        ctx.fillText(pos.label, canvas.width/2, pos.y - p.radius - 15);
        ctx.fillStyle="#fff"; ctx.font = `bold ${pos.nameSize}px Chakra Petch`;
        ctx.fillText(`@${p.username}`, canvas.width/2, pos.y + p.radius + 30);
    });
}

function animate(time){
    if(!ctx) return;
    const dt=(time-lastTime)/1000 || 0; lastTime=time;

    const alive = profiles.filter(p=>p.alive);
    
    detectCollisions(alive);
    
    alive.forEach(p=>p.update(dt, alive.length));
    
    if(alive.length<=1 && followerImageUrls.length > 1) isGameOver=true;
    
    ctx.clearRect(0,0,canvas.width,canvas.height);

    if(isGameOver){
        drawPodium();
        searchRanking();
        
        // NOVO: Exibe o bot√£o de exportar quando o jogo termina
        document.getElementById('exportRankingButton').style.display = 'block'; 
        document.getElementById('statusMessage').textContent = 'FIM DE JOGO! Salve o ranking para publicar.';

    } else {
        alive.forEach(p=>p.draw(ctx, alive.length));
        animationFrameId=requestAnimationFrame(animate);
        // NOVO: Esconde o bot√£o se o jogo estiver rodando
        document.getElementById('exportRankingButton').style.display = 'none';
    }
    
    ctx.fillStyle="#fff"; ctx.font="bold 20px Chakra Petch"; ctx.textAlign="left";
    ctx.fillText(`Vivos: ${alive.length}`, 10,25);
}

function searchRanking() {
    const searchInput = document.getElementById('searchInput'); const searchResults = document.getElementById('searchResults'); const searchTerm = searchInput.value.toLowerCase();
    searchResults.innerHTML = ''; if (searchTerm.length < 1 || profiles.length === 0) { return; }
    const filteredProfiles = profiles.filter(p => p.username.toLowerCase().includes(searchTerm));
    const totalParticipants = followerImageUrls.length;
    filteredProfiles.slice(0, 5).forEach(p => { let rankStatus = ''; if (p.alive) { if (isGameOver && profiles.filter(pr=>pr.alive).length === 1 && profiles.filter(pr=>pr.alive)[0].id === p.id) { rankStatus = 'üèÜ CAMPE√ÉO!'; } else { rankStatus = 'Vivo'; } } else { const rank = totalParticipants - p.eliminationOrder + 1; if (isGameOver) { const dead = profiles.filter(pr=>!pr.alive).sort((a,b)=>b.eliminationOrder - a.eliminationOrder); if (dead[0] && dead[0].id === p.id) rankStatus = 'ü•à 2¬∫ Lugar'; else if (dead[1] && dead[1].id === p.id) rankStatus = 'ü•â 3¬∫ Lugar'; else rankStatus = `Eliminado em ${rank}¬∫`; } else { rankStatus = `Eliminado em ${rank}¬∫`; } }
    const resultDiv = document.createElement('div'); resultDiv.className = 'result-item'; 
    const imageUrl = followerImageUrls[p.id]?.url || ''; // Garante que a URL da imagem existe
    resultDiv.innerHTML = `<img src="${imageUrl}" alt="${p.username}"><div class="result-info"><span class="username">@${p.username}</span><span class="rank">${rankStatus}</span></div>`; 
    searchResults.appendChild(resultDiv); });
}


// --- NOVO C√ìDIGO: FUN√á√ÉO PARA EXPORTAR OS DADOS DO RANKING ---
function exportRanking() {
    if (!isGameOver) {
        alert("A simula√ß√£o ainda n√£o terminou. Por favor, aguarde o fim da rodada para exportar o ranking.");
        return;
    }

    const finalRanking = profiles
        .sort((a, b) => {
            // Ordena o campe√£o para o topo (1¬∫)
            if (a.alive && !b.alive) return -1;
            if (!a.alive && b.alive) return 1;
            
            // Para eliminados, ordena do √∫ltimo eliminado para o primeiro eliminado
            // O √∫ltimo a ser eliminado tem o maior eliminationOrder e ser√° o 2¬∫ lugar, 3¬∫ lugar, etc.
            if (!a.alive && !b.alive) {
                return b.eliminationOrder - a.eliminationOrder;
            }
            return 0; 
        })
        .map((p, index) => {
            // A posi√ß√£o real na lista ordenada
            let rank = index + 1; 
            let rankStatus = '';
            
            if (p.alive) {
                rankStatus = 'üèÜ CAMPE√ÉO!';
                rank = 1; 
            } else {
                if (rank === 2) rankStatus = 'ü•à 2¬∫ Lugar';
                else if (rank === 3) rankStatus = 'ü•â 3¬∫ Lugar';
                else rankStatus = `Eliminado em ${rank}¬∫`;
            }
            
            // Busca a URL original para inclus√£o no JSON
            const imageUrl = followerImageUrls.find(img => img.name === p.username)?.url || p.image.src;

            return {
                username: p.username,
                rank: rank,
                status: rankStatus,
                imageUrl: imageUrl
            };
        });

    // Converte para JSON
    const jsonString = JSON.stringify(finalRanking, null, 2);
    
    // Cria um link para download do arquivo 'ranking_final.json'
    const blob = new Blob([jsonString], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = 'ranking_final.json'; // O nome do arquivo que voc√™ vai subir para o Vercel
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);

    alert("O arquivo 'ranking_final.json' foi baixado! Voc√™ deve substituir o arquivo no seu reposit√≥rio Git e fazer o PUSH para o Vercel/GitHub para atualizar o ranking p√∫blico.");
}
// --- FIM DO NOVO C√ìDIGO: FUN√á√ÉO PARA EXPORTAR OS DADOS DO RANKING ---


// --- INICIALIZA√á√ÉO E LISTENERS ---
document.getElementById('imageUpload').addEventListener('change',(e)=>{
    const files=Array.from(e.target.files);
    if(files.length===0) return;
    const readers=files.map(f=>new Promise((res,rej)=>{
        const r=new FileReader();
        r.onload = () => res({ url: r.result, name: f.name.replace(/\.[^/.]+$/, '') });
        r.onerror=rej;
        r.readAsDataURL(f);
    }));
    Promise.all(readers).then(results=>{
        followerImageUrls=results;
        initProfiles();
        if(animationFrameId) cancelAnimationFrame(animationFrameId);
        animate(performance.now());
    });
});
document.getElementById('resetButton').addEventListener('click',()=>{
    if (followerImageUrls.length === 0) return;
    cancelAnimationFrame(animationFrameId);
    initProfiles();
    animate(performance.now());
});
document.getElementById('searchInput').addEventListener('input', searchRanking);

// NOVO: Adiciona o listener de clique ao bot√£o de exportar
document.getElementById('exportRankingButton').addEventListener('click', exportRanking);


canvas = document.getElementById('collisionCanvas');
ctx = canvas.getContext('2d');
ctx.clearRect(0, 0, canvas.width, canvas.height);
</script>
</body>
</html>
