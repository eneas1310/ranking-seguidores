<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Simulador - Arena do Insta</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
@import url('https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@400;700&display=swap');

body {
Â  Â  font-family: 'Chakra Petch', sans-serif;
Â  Â  background-color: #1a1a2e;
Â  Â  color: #fff;
Â  Â  margin: 0;
Â  Â  display: flex;
Â  Â  justify-content: center;
Â  Â  align-items: flex-start;
Â  Â  padding: 20px;
Â  Â  min-height: 100vh;
Â  Â  position: relative; /* NecessÃ¡rio para o painel lateral */
}

#app-container {
Â  Â  display: flex;
Â  Â  flex-direction: column;
Â  Â  align-items: center;
Â  Â  gap: 15px;
}

canvas {
Â  Â  background-color:#0d0d1b;
Â  Â  border-radius:10px;
Â  Â  box-shadow:inset 0 0 10px rgba(0,0,0,0.7);
Â  Â  display:block;
}

.header {
Â  Â  background-color: #2c2c54;
Â  Â  padding: 20px;
Â  Â  margin-bottom: 10px;
Â  Â  border-radius: 8px;
Â  Â  text-align: center;
Â  Â  width: 750px;
}

.status-box {
Â  Â  background-color: #2c2c54;
Â  Â  border-radius: 8px;
Â  Â  padding: 15px;
Â  Â  box-shadow:0 2px 10px rgba(0,0,0,0.5);
Â  Â  width: 750px;
Â  Â  display:flex;
Â  Â  flex-direction: column;
Â  Â  align-items:center;
Â  Â  gap: 10px;
}

.action-button {
Â  Â  transition:all 0.2s ease-in-out;
Â  Â  padding:10px 20px;
Â  Â  border-radius:8px;
Â  Â  font-weight:bold;
Â  Â  cursor:pointer;
Â  Â  text-align:center;
Â  Â  width:90%;
Â  Â  color: white;
}
.action-button:hover {
Â  Â  opacity:0.9;
}

.upload-label { background-color:#22c55e; } /* Verde */
.export-button { background-color: #0284c7; } /* Azul Ciano */

/* ===== ESTILO DO PAINEL LATERAL RE-ADICIONADO ===== */
#side-panel {
Â  Â  position: absolute;
Â  Â  right: 20px;
Â  Â  top: 50%;
Â  Â  transform: translateY(-50%);
Â  Â  width: 220px;
Â  Â  background-color: #2c2c54;
Â  Â  border-radius: 8px;
Â  Â  padding: 15px;
Â  Â  box-shadow: 0 4px 15px rgba(0,0,0,0.5);
}
#side-panel button {
Â  Â  background-color: #d97706; /* Laranja */
Â  Â  color: white;
Â  Â  width: 100%;
Â  Â  padding: 10px;
Â  Â  border-radius: 6px;
Â  Â  font-weight: bold;
Â  Â  cursor: pointer;
Â  Â  transition: all 0.2s ease;
}
#side-panel button:hover {
Â  Â  opacity: 0.9;
}

</style>
</head>
<body>

<div id="app-container">
Â  Â  <div class="header">
Â  Â  Â  Â  <h1 class="text-4xl font-bold mb-2">ARENA DO INSTA</h1>
Â  Â  Â  Â  <p class="text-gray-300 mt-1 text-xl">Simulador de Rodadas</p>
Â  Â  </div>

Â  Â  <canvas id="collisionCanvas" width="750" height="600"></canvas>

Â  Â  <div class="status-box">
Â  Â  Â  Â  <div id="statusMessage" class="text-lg font-semibold text-yellow-300 text-center">Aguardando imagens...</div>
Â  Â  Â  Â Â 
Â  Â  Â  Â  <input type="file" id="imageUpload" multiple accept="image/*" style="display:none;">
Â  Â  Â  Â  <label for="imageUpload" class="action-button upload-label">ğŸ–¼ï¸ Carregar Fotos</label>
Â  Â  Â  Â Â 
Â  Â  Â  Â  <button id="exportRankingButton" class="action-button export-button" style="display:none;">ğŸ† Salvar Ranking Final (.json)</button>
Â  Â  </div>
</div>

<div id="side-panel">
Â  Â  <button id="resetButton" style="display:none;">ğŸ”„ Reiniciar SimulaÃ§Ã£o</button>
</div>


<script>
// --- Constantes da SimulaÃ§Ã£o ---
const INITIAL_RADIUS = 2;
const MAX_RADIUS = 60;
const MAX_SPEED = 1.5;
const MIN_SPEED = 0.5;
const ELIMINATION_THRESHOLD = 15;
const NORMAL_GROWTH_RATE = 0.05;
const SLOW_GROWTH_RATE = 0.01;

// --- VariÃ¡veis Globais ---
let canvas, ctx, profiles=[], animationFrameId, isGameOver=false, lastTime=0, followerImageUrls=[];
let eliminationCounter = 1;
const imageCache = new Map();
let grid;

class SpatialGrid {
Â  Â  constructor(width, height, cellSize) { this.cellSize = cellSize; this.cols = Math.ceil(width / cellSize); this.rows = Math.ceil(height / cellSize); this.grid = new Map(); }
Â  Â  clear() { this.grid.clear(); }
Â  Â  insert(profile) { const col = Math.floor(profile.x / this.cellSize); const row = Math.floor(profile.y / this.cellSize); const key = `${col},${row}`; if (!this.grid.has(key)) { this.grid.set(key, []); } this.grid.get(key).push(profile); }
Â  Â  getNearby(profile) { const nearby = []; const col = Math.floor(profile.x / this.cellSize); const row = Math.floor(profile.y / this.cellSize); for (let r = -1; r <= 1; r++) { for (let c = -1; c <= 1; c++) { const key = `${col + c},${row + r}`; if (this.grid.has(key)) { nearby.push(...this.grid.get(key)); } } } return nearby; }
}

class Profile {
Â  Â  constructor(id, username, x, y, vx, vy, imageUrl){
Â  Â  Â  Â  this.id=id; this.username=username; this.x=x; this.y=y; this.vx=vx; this.vy=vy;
Â  Â  Â  Â  this.radius=INITIAL_RADIUS; this.collisionCount=0; this.alive=true;
Â  Â  Â  Â  this.eliminationOrder = null;
Â  Â  Â  Â  this.image=imageCache.get(imageUrl);
Â  Â  Â  Â  if(!this.image){ this.image=new Image(); this.image.src=imageUrl; imageCache.set(imageUrl,this.image); }
Â  Â  }
Â  Â  update(dt,totalAlive){
Â  Â  Â  Â  if(!this.alive) return;
Â  Â  Â  Â  let speedFactor = Math.max(MIN_SPEED, Math.min(MAX_SPEED, Math.pow(followerImageUrls.length / totalAlive, 0.4)));
Â  Â  Â  Â  if(totalAlive <= 10) speedFactor *= 1.8;
Â  Â  Â  Â  if(totalAlive <= 5) speedFactor *= 2.0;
Â  Â  Â  Â  if(Math.abs(this.vx)<0.2) this.vx += this.vx>0?0.2:-0.2;
Â  Â  Â  Â  if(Math.abs(this.vy)<0.2) this.vy += this.vy>0?0.2:-0.2;
Â  Â  Â  Â  this.x += this.vx * dt * 60 * speedFactor;
Â  Â  Â  Â  this.y += this.vy * dt * 60 * speedFactor;
Â  Â  Â  Â  let currentGrowthRate = NORMAL_GROWTH_RATE;
Â  Â  Â  Â  if (totalAlive <= 50) { currentGrowthRate = SLOW_GROWTH_RATE; }
Â  Â  Â  Â  const dynamicFinalRadius = INITIAL_RADIUS + (MAX_RADIUS - INITIAL_RADIUS) * (1 - totalAlive / followerImageUrls.length);
Â  Â  Â  Â  if(this.radius < dynamicFinalRadius){ this.radius += currentGrowthRate * dt * 60; if(this.radius > dynamicFinalRadius) this.radius = dynamicFinalRadius; }
Â  Â  Â  Â  if(this.x-this.radius<0){ this.x=this.radius; this.vx*=-1;}
Â  Â  Â  Â  else if(this.x+this.radius>canvas.width){ this.x=canvas.width-this.radius; this.vx*=-1;}
Â  Â  Â  . y-this.radius<0){ this.y=this.radius; this.vy*=-1;}
Â  Â  Â  Â  else if(this.y+this.radius>canvas.height){ this.y=canvas.height-this.radius; this.vy*=-1;}
Â  Â  }
Â  Â  draw(ctx, aliveCount){
Â  Â  Â  Â  if(!this.alive) return;
Â  Â  Â  Â  if(aliveCount <= 200){
Â  Â  Â  Â  Â  Â  const barW = this.radius*2; const barH = 3; const barX = this.x - barW/2; const barY = this.y - this.radius - 5;
Â  Â  Â  Â  Â  Â  const healthRatio = (ELIMINATION_THRESHOLD - this.collisionCount)/ELIMINATION_THRESHOLD;
Â  Â  Â  Â  Â  Â  ctx.fillStyle = "rgba(51,51,51,0.6)"; ctx.fillRect(barX, barY, barW, barH);
Â  Â  Â  Â  Â  Â  let barColor = healthRatio > 0.6 ? "limegreen" : healthRatio > 0.3 ? "gold" : "red";
Â  Â  Â  Â  Â  Â  ctx.fillStyle = barColor; ctx.fillRect(barX, barY, barW * healthRatio, barH);
Â  Â  Â  Â  Â  Â  ctx.strokeStyle = "rgba(255,255,255,0.3)"; ctx.strokeRect(barX, barY, barW, barH);
Â  Â  Â  Â  }
Â  Â  Â  Â  ctx.save(); ctx.beginPath(); ctx.arc(this.x,this.y,this.radius,0,Math.PI*2); ctx.clip();
Â  Â  Â  Â  ctx.drawImage(this.image,this.x-this.radius,this.y-this.radius,this.radius*2,this.radius*2);
Â  Â  Â  Â  ctx.restore();
Â  Â  }
}

function initProfiles(){
Â  Â  canvas=document.getElementById('collisionCanvas'); ctx=canvas.getContext('2d');
Â  Â  grid = new SpatialGrid(canvas.width, canvas.height, MAX_RADIUS * 2);
Â  Â  profiles=[]; isGameOver=false; lastTime=performance.now();
Â  Â  eliminationCounter = 1;
Â  Â  document.getElementById('statusMessage').textContent = `${followerImageUrls.length} perfis em batalha!`;
Â  Â  document.getElementById('exportRankingButton').style.display = 'none';
Â  Â  document.getElementById('resetButton').style.display = 'block';

Â  Â  for(let i=0;i<followerImageUrls.length;i++){
Â  Â  Â  Â  const imageObj=followerImageUrls[i];
Â  Â  Â  Â  let x=Math.random()*(canvas.width-INITIAL_RADIUS*2)+INITIAL_RADIUS;
Â  Â  Â  Â  let y=Math.random()*(canvas.height-INITIAL_RADIUS*2)+INITIAL_RADIUS;
Â  Â  Â  Â  profiles.push(new Profile(i, imageObj.name, x, y, (Math.random()-0.5)*MAX_SPEED, (Math.random()-0.5)*MAX_SPEED, imageObj.url));
Â  Â  }
}

function detectCollisions(alive) {
Â  Â  if(alive.length < 2) return;
Â  Â  if(alive.length === 2){
Â  Â  Â  Â  const [p1, p2] = alive;
Â  Â  Â  Â  if(Math.hypot(p2.x - p1.x, p2.y - p1.y) < p1.radius + p2.radius){
Â  Â  Â  Â  Â  Â  let loser = (p1.collisionCount < p2.collisionCount) ? p2 : (p2.collisionCount < p1.collisionCount) ? p1 : (Math.random() < 0.5 ? p1 : p2);
Â  Â  Â  Â  Â  Â  loser.alive = false; loser.eliminationOrder = eliminationCounter++;
Â  Â  Â  Â  }
Â  Â  Â  Â  return;
Â  Â  }
Â  Â  grid.clear();
Â  Â  alive.forEach(p => grid.insert(p));
Â  Â  for (const p1 of alive) {
Â  Â  Â  Â  for (const p2 of grid.getNearby(p1)) {
Â  Â  Â  Â  Â  Â  if (p1.id >= p2.id) continue;
Â  Â  Â  Â  Â  Â  if (Math.hypot(p2.x - p1.x, p2.y - p1.y) < p1.radius + p2.radius) {
Â  Â  Â  Â  Â  Â  Â  Â  const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
Â  Â  Â  Â  Â  Â  Â  Â  p1.vx*=-1; p1.vy*=-1; p2.vx*=-1; p2.vy*=-1;
Â  Â  Â  Â  Â  Â  Â  Â  p1.collisionCount++; p2.collisionCount++;
Â  Â  Â  Â  Â  Â  Â  Â  if(p1.collisionCount>=ELIMINATION_THRESHOLD && p1.alive){ p1.alive=false; p1.eliminationOrder = eliminationCounter++; }
Â  Â  Â  Â  Â  Â  Â  Â  if(p2.collisionCount>=ELIMINATION_THRESHOLD && p2.alive){ p2.alive=false; p2.eliminationOrder = eliminationCounter++; }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  }
}

function drawPodium() {
Â  Â  const alive = profiles.filter(p=>p.alive);
Â  Â  if(alive.length === 0) return;
Â  Â  const champion = alive[0];
Â  Â  const dead = profiles.filter(p=>!p.alive).sort((a,b)=>b.eliminationOrder - a.eliminationOrder);
Â  Â  const podiumData = [
Â  Â  Â  Â  {profile: champion, y: canvas.height*0.20, label:"CAMPEÃƒO", radius: canvas.width*0.45, fontSize:36, nameSize:26},
Â  Â  Â  Â  dead[0] ? {profile: dead[0], y: canvas.height*0.55, label:"2Âº LUGAR", radius: canvas.width*0.28, fontSize:24, nameSize:16} : null,
Â  Â  Â  Â  dead[1] ? {profile: dead[1], y: canvas.height*0.82, label:"3Âº LUGAR", radius: canvas.width*0.18, fontSize:24, nameSize:16} : null
Â  Â  ].filter(Boolean);
Â  Â Â 
Â  Â  podiumData.forEach(pos=>{
Â  Â  Â  Â  const p = pos.profile;
Â  Â  Â  Â  p.radius += (pos.radius - p.radius) * 0.05;
Â  Â  Â  Â  ctx.save(); ctx.beginPath(); ctx.arc(canvas.width/2, pos.y, p.radius, 0, Math.PI*2); ctx.clip();
Â  Â  Â  Â  ctx.drawImage(p.image, canvas.width/2 - p.radius, pos.y - p.radius, p.radius*2, p.radius*2); ctx.restore();
Â  Â  Â  Â  ctx.fillStyle="gold"; ctx.textAlign="center"; ctx.font = `bold ${pos.fontSize}px Chakra Petch`;
Â  Â  Â  Â  ctx.fillText(pos.label, canvas.width/2, pos.y - p.radius - 15);
Â  Â  Â  Â  ctx.fillStyle="#fff"; ctx.font = `bold ${pos.nameSize}px Chakra Petch`;
Â  Â  Â  Â  ctx.fillText(`@${p.username}`, canvas.width/2, pos.y + p.radius + 30);
Â  Â  });
}

function animate(time){
Â  Â  if(!ctx) return;
Â  Â  const dt=(time-lastTime)/1000 || 0; lastTime=time;
Â  Â  const alive = profiles.filter(p=>p.alive);
Â  Â Â 
Â  Â  detectCollisions(alive);
Â  Â  alive.forEach(p=>p.update(dt, alive.length));
Â  Â Â 
Â  Â  if(alive.length<=1 && followerImageUrls.length > 1) isGameOver=true;
Â  Â Â 
Â  Â  ctx.clearRect(0,0,canvas.width,canvas.height);

Â  Â  if(isGameOver){
Â  Â  Â  Â  drawPodium();
Â  Â  Â  Â  document.getElementById('exportRankingButton').style.display = 'block';
Â  Â  Â  Â  document.getElementById('statusMessage').textContent = 'FIM DE JOGO! Salve o ranking para publicar.';
Â  Â  } else {
Â  Â  Â  Â  alive.forEach(p=>p.draw(ctx, alive.length));
Â  Â  Â  Â  animationFrameId=requestAnimationFrame(animate);
Â  Â  }
Â  Â Â 
Â  Â  ctx.fillStyle="#fff"; ctx.font="bold 20px Chakra Petch"; ctx.textAlign="left";
Â  Â  ctx.fillText(`Vivos: ${alive.length}`, 10,25);
}

function exportRanking() {
Â  Â  if (!isGameOver) {
Â  Â  Â  Â  alert("A simulaÃ§Ã£o precisa terminar para exportar o ranking.");
Â  Â  Â  Â  return;
Â  Â  }
Â  Â  const finalRanking = profiles
Â  Â  Â  Â  .sort((a, b) => {
Â  Â  Â  Â  Â  Â  if (a.alive && !b.alive) return -1;
Â  Â  Â  Â  Â  Â  if (!a.alive && b.alive) return 1;
Â  Â  Â  Â  Â  Â  if (!a.alive && !b.alive) return b.eliminationOrder - a.eliminationOrder;
Â  Â  Â  Â  Â  Â  return 0;
Â  Â  Â  Â  })
Â  Â  Â  Â  .map((p, index) => {
Â  Â  Â  Â  Â  Â  const rank = index + 1;
Â  Â  Â  Â  Â  Â  let rankStatus = p.alive ? 'ğŸ† CAMPEÃƒO!' : rank === 2 ? 'ğŸ¥ˆ 2Âº Lugar' : rank === 3 ? 'ğŸ¥‰ 3Âº Lugar' : `Eliminado em ${rank}Âº`;
Â  Â  Â  Â  Â  Â  return {
Â  Â  Â  Â  Â  Â  Â  Â  username: p.username,
Â  Â  Â  Â  Â  Â  Â  Â  rank: rank,
Â  Â  Â  Â  Â  Â  Â  Â  status: rankStatus,
Â  Â  Â  Â  Â  Â  Â  Â  imageUrl: followerImageUrls.find(img => img.name === p.username)?.url || p.image.src
Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  });

Â  Â  const blob = new Blob([JSON.stringify(finalRanking, null, 2)], { type: 'application/json' });
Â  Â  const url = URL.createObjectURL(blob);
Â  Â  const a = document.createElement('a');
Â  Â  a.href = url;
Â  Â  a.download = 'ranking_final.json';
Â  Â  a.click();
Â  Â  URL.revokeObjectURL(url);
Â  Â  alert("Arquivo 'ranking_final.json' baixado com sucesso!");
}

document.addEventListener('DOMContentLoaded', () => {
Â  Â  canvas = document.getElementById('collisionCanvas');
Â  Â  ctx = canvas.getContext('2d');
Â  Â  ctx.clearRect(0, 0, canvas.width, canvas.height);

Â  Â  document.getElementById('imageUpload').addEventListener('change', (e) => {
Â  Â  Â  Â  const files=Array.from(e.target.files);
Â  Â  Â  Â  if(files.length===0) return;
Â  Â  Â  Â  const readers=files.map(f=>new Promise((res,rej)=>{
Â  Â  Â  Â  Â  Â  const r=new FileReader();
Â  Â  Â  Â  Â  Â  r.onload = () => res({ url: r.result, name: f.name.replace(/\.[^/.]+$/, '') });
Â  Â  Â  Â  Â  Â  r.onerror=rej; r.readAsDataURL(f);
Â  Â  Â  Â  }));
Â  Â  Â  Â  Promise.all(readers).then(results=>{
Â  Â  Â  Â  Â  Â  followerImageUrls=results;
Â  Â  Â  Â  Â  Â  initProfiles();
Â  Â  Â  Â  Â  Â  if(animationFrameId) cancelAnimationFrame(animationFrameId);
Â  Â  Â  Â  Â  Â  animate(performance.now());
Â  Â  Â  Â  });
Â  Â  });

Â  Â  document.getElementById('resetButton').addEventListener('click', () => {
Â  Â  Â  Â  if (followerImageUrls.length === 0) {
Â  Â  Â  Â  Â  Â  Â alert("Carregue as imagens primeiro para reiniciar.");
Â  Â  Â  Â  Â  Â  Â return;
Â  Â  Â  Â  }
Â  Â  Â  Â  cancelAnimationFrame(animationFrameId);
Â  Â  Â  Â  initProfiles();
Â  Â  Â  Â  animate(performance.now());
Â  Â  });

Â  Â  document.getElementById('exportRankingButton').addEventListener('click', exportRanking);
});
</script>
</body>
</html>